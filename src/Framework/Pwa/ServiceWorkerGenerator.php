<?php

namespace Lightpack\Pwa;

/**
 * ServiceWorkerGenerator - Generates service worker JavaScript
 * 
 * Creates a customized service worker with caching strategies,
 * offline support, and background sync capabilities.
 */
class ServiceWorkerGenerator
{
    protected string $publicPath;

    public function __construct(string $publicPath)
    {
        $this->publicPath = $publicPath;
    }

    /**
     * Generate service worker file
     */
    public function generate(array $config): void
    {
        $js = $this->buildServiceWorker($config);
        $this->write($js);
    }

    /**
     * Build service worker JavaScript
     */
    protected function buildServiceWorker(array $config): string
    {
        $cacheName = $config['cache_name'];
        $precache = json_encode($config['precache']);
        $offlinePage = $config['offline_page'];
        $runtimeCache = $config['runtime_cache'];

        $js = <<<JS
// Service Worker for PWA
// Generated by Lightpack PWA

const CACHE_NAME = '{$cacheName}';
const OFFLINE_PAGE = '{$offlinePage}';

// Files to cache on install
const PRECACHE_URLS = {$precache};

// Install event - cache essential files
self.addEventListener('install', (event) => {
    console.log('[SW] Installing service worker...');
    
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then((cache) => {
                console.log('[SW] Precaching files');
                return cache.addAll(PRECACHE_URLS);
            })
            .then(() => self.skipWaiting())
    );
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
    console.log('[SW] Activating service worker...');
    
    event.waitUntil(
        caches.keys()
            .then((cacheNames) => {
                return Promise.all(
                    cacheNames
                        .filter((name) => name !== CACHE_NAME)
                        .map((name) => {
                            console.log('[SW] Deleting old cache:', name);
                            return caches.delete(name);
                        })
                );
            })
            .then(() => self.clients.claim())
    );
});

// Fetch event - serve from cache with fallback strategies
self.addEventListener('fetch', (event) => {
    const { request } = event;
    const url = new URL(request.url);

    // Skip non-GET requests
    if (request.method !== 'GET') {
        return;
    }

    // Skip cross-origin requests
    if (url.origin !== location.origin) {
        return;
    }

JS;

        // Add runtime caching strategies
        if (!empty($runtimeCache)) {
            $js .= $this->generateRuntimeCaching($runtimeCache);
        } else {
            // Default: network-first with offline fallback
            $js .= <<<JS

    // Default strategy: Network first, fallback to cache
    event.respondWith(
        fetch(request)
            .then((response) => {
                // Clone response to cache it
                const responseToCache = response.clone();
                caches.open(CACHE_NAME)
                    .then((cache) => {
                        cache.put(request, responseToCache);
                    });
                return response;
            })
            .catch(() => {
                return caches.match(request)
                    .then((cachedResponse) => {
                        if (cachedResponse) {
                            return cachedResponse;
                        }
                        // Return offline page for navigation requests
                        if (request.mode === 'navigate') {
                            return caches.match(OFFLINE_PAGE);
                        }
                    });
            })
    );
JS;
        }

        $js .= <<<JS

});

// Background sync for offline actions
self.addEventListener('sync', (event) => {
    console.log('[SW] Background sync:', event.tag);
    
    if (event.tag === 'sync-data') {
        event.waitUntil(syncData());
    }
});

async function syncData() {
    // Implement your background sync logic here
    console.log('[SW] Syncing data...');
}

// Push notification handler
self.addEventListener('push', (event) => {
    console.log('[SW] Push notification received');
    
    let data = {};
    if (event.data) {
        data = event.data.json();
    }

    const title = data.title || 'Notification';
    const options = {
        body: data.body || '',
        icon: data.icon || '/icons/icon-192x192.png',
        badge: data.badge || '/icons/icon-96x96.png',
        data: data.data || {},
        requireInteraction: data.requireInteraction || false,
        vibrate: data.vibrate || [200, 100, 200],
        actions: data.actions || []
    };

    event.waitUntil(
        self.registration.showNotification(title, options)
    );
});

// Notification click handler
self.addEventListener('notificationclick', (event) => {
    console.log('[SW] Notification clicked');
    
    event.notification.close();

    const urlToOpen = event.notification.data?.url || '/';

    event.waitUntil(
        clients.matchAll({ type: 'window', includeUncontrolled: true })
            .then((clientList) => {
                // Check if app is already open
                for (const client of clientList) {
                    if (client.url === urlToOpen && 'focus' in client) {
                        return client.focus();
                    }
                }
                // Open new window
                if (clients.openWindow) {
                    return clients.openWindow(urlToOpen);
                }
            })
    );
});

// Message handler for communication with app
self.addEventListener('message', (event) => {
    console.log('[SW] Message received:', event.data);
    
    if (event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
    }
    
    if (event.data.type === 'CLEAR_CACHE') {
        event.waitUntil(
            caches.delete(CACHE_NAME)
                .then(() => {
                    console.log('[SW] Cache cleared');
                })
        );
    }
});

console.log('[SW] Service worker loaded');

JS;

        return $js;
    }

    /**
     * Generate runtime caching strategies
     */
    protected function generateRuntimeCaching(array $strategies): string
    {
        $js = "\n    // Runtime caching strategies\n";

        foreach ($strategies as $pattern => $strategy) {
            $js .= $this->generateStrategyCode($pattern, $strategy);
        }

        return $js;
    }

    /**
     * Generate code for specific caching strategy
     */
    protected function generateStrategyCode(string $pattern, string $strategy): string
    {
        $regex = $this->patternToRegex($pattern);

        switch ($strategy) {
            case 'cache-first':
                return $this->cacheFirstStrategy($regex);
            case 'network-first':
                return $this->networkFirstStrategy($regex);
            case 'stale-while-revalidate':
                return $this->staleWhileRevalidateStrategy($regex);
            case 'network-only':
                return $this->networkOnlyStrategy($regex);
            case 'cache-only':
                return $this->cacheOnlyStrategy($regex);
            default:
                return $this->networkFirstStrategy($regex);
        }
    }

    /**
     * Convert pattern to regex
     */
    protected function patternToRegex(string $pattern): string
    {
        $pattern = str_replace('/', '\/', $pattern);
        $pattern = str_replace('*', '.*', $pattern);
        return '/' . $pattern . '/';
    }

    /**
     * Cache-first strategy
     */
    protected function cacheFirstStrategy(string $regex): string
    {
        return <<<JS

    if ({$regex}.test(url.pathname)) {
        event.respondWith(
            caches.match(request)
                .then((cachedResponse) => {
                    if (cachedResponse) {
                        return cachedResponse;
                    }
                    return fetch(request).then((response) => {
                        const responseToCache = response.clone();
                        caches.open(CACHE_NAME).then((cache) => {
                            cache.put(request, responseToCache);
                        });
                        return response;
                    });
                })
        );
        return;
    }

JS;
    }

    /**
     * Network-first strategy
     */
    protected function networkFirstStrategy(string $regex): string
    {
        return <<<JS

    if ({$regex}.test(url.pathname)) {
        event.respondWith(
            fetch(request)
                .then((response) => {
                    const responseToCache = response.clone();
                    caches.open(CACHE_NAME).then((cache) => {
                        cache.put(request, responseToCache);
                    });
                    return response;
                })
                .catch(() => caches.match(request))
        );
        return;
    }

JS;
    }

    /**
     * Stale-while-revalidate strategy
     */
    protected function staleWhileRevalidateStrategy(string $regex): string
    {
        return <<<JS

    if ({$regex}.test(url.pathname)) {
        event.respondWith(
            caches.match(request)
                .then((cachedResponse) => {
                    const fetchPromise = fetch(request).then((response) => {
                        const responseToCache = response.clone();
                        caches.open(CACHE_NAME).then((cache) => {
                            cache.put(request, responseToCache);
                        });
                        return response;
                    });
                    return cachedResponse || fetchPromise;
                })
        );
        return;
    }

JS;
    }

    /**
     * Network-only strategy
     */
    protected function networkOnlyStrategy(string $regex): string
    {
        return <<<JS

    if ({$regex}.test(url.pathname)) {
        event.respondWith(fetch(request));
        return;
    }

JS;
    }

    /**
     * Cache-only strategy
     */
    protected function cacheOnlyStrategy(string $regex): string
    {
        return <<<JS

    if ({$regex}.test(url.pathname)) {
        event.respondWith(caches.match(request));
        return;
    }

JS;
    }

    /**
     * Write service worker to file
     */
    protected function write(string $js): void
    {
        $path = $this->publicPath . '/sw.js';

        if (file_put_contents($path, $js) === false) {
            throw new \RuntimeException("Failed to write service worker to {$path}");
        }
    }
}
